init
clone [url]
branch - локальная ветка, git branch branchName - создать ветку, git branch -d branchName - удалить ветку
origin [branch] - удаленная ветка
origin/branch - локальная не рабочая версия ветки, хранит состояние удаленной ветки
clone / - склонировать репозиторий
add / - добавить отслеживаемие файли
rm / - убрать из отслеживаемих
commit / - комит, git commit -m "Text commit"
fetch / - проверить наличие изменений в удаленном репозитории
push / - отправить на удаленный сервер
pull / == (git fetch & git merge)
rebase / - локальные коммиты применяются поверх новых коммитов из мастера, ломает историю у других пользователей, применяй только к своей локальной ветке, история ленейная и без ответвлений, 
	git rebase -i commitHash - сливаем два коммита 	в один, 
	git pull --rebase == git remote update == git rebase origin/master
merge / - создает ветвление, merge commit - создается при разрешении конфликтов, git pull == git remote update == git merge origin/master
cherry-pick / - копировать коммит
status / - состояние локальной ветки
reset / - отменить коммит, git reset --soft HEAD^, git reset fileName.txt, git reset --hard
checkout / - переключится на другую ветку, git checkout -b branch_name origin/master - создать новую ветку и перейти на нее, git checkout [branchName или hash] file.txt - востановить старую версию конкретного файла
log / - история всех изменений в репозитории
show [comitHash] / - показать информацию по конкретному комиту
blame [fileName] / - показать автора файла, git blame file.txt | grep someString - показать автора конкретной строки в файле 
diff / - показать информацию о модификации локального репозитория которые будут закомиченны, git diff --cached
stash / - позволяет на время "сдать в архив" (или отложить) изменения, сделанные в рабочей копии, чтобы применить их позже
reflog / - история действий
revert / - создаст коммит отменяющий изменения указанного коммита
restore / - востановить удаленный файл

git revert [commit SHA] - создаст коммит отменяющий изменения указанного коммита
git push [repository]/branch-name
git rebase -i - ошибочный коммит можно отметить флагом drop в интерактивном режиме ребейза (git rebase -i), что полностью удалит указанный коммит из истории
git push -f [repository]/branch-name

Staging area (область подготовленных файлов) — файл, который как правило, располагается в Git-директории и содержит информацию об изменениях, которые попадут в следующий коммит.
Git stash — команда сохраняющая измененное состояние рабочей директории или отдельного файла в хранилище незавершенных изменений. Это дает возможность в любой момент применить их обратно. Например, если нужно переключиться между ветками без фиксации изменений, можно применить команду git stash, рабочая директория останется без изменений, данные будут сохранены в специальном хранилище. Для просмотра спрятанных изменений нужно вызвать команду git stash list, а для применения — git stash apply.

Объединить несколько отдельных коммитов в один цельный коммит - с помощью перебазирования в интерактивном режиме работы (rebase). Например, для того, чтобы объединить, 3 последних коммита в один, необходимо выполнить команду git rebase -i HEAD~3 (3 соответствует числу коммитов, которые нужно объединить, отсчет от HEAD). Откроется окно редактора, в котором первые 3 строки соответствуют последним трем коммитам:
	pick ab37583 Added feature 1.
	pick 3ab2b83 Added feature 2.
	pick 3ab5683 Added feature 3
	В начале каждой строки стоит слово pick. Нужно поменять его на squash или s, сохранить изменения, закрыть редактор, после чего git попросит задать сообщение нового коммита, содержащего в себе изменения трех исходных.

С помощью хука pre-commit можно настроить Git-репозиторий для запуска инструментов проверки работоспособности кода непосредственно перед выполнением коммитов и предотвращения их в случае сбоя теста. Для этого нужно определить в конфигурационном файле pre-commit (в папке .git/hooks), код проверки работоспособности внесенных изменений. После этого, Git будет запускать указанную проверку перед каждым коммитом. В случае если проверка вернет код отличный от нуля, коммит не будет применен.

Команда git rebase (перебазирование) — применяет коммиты текущей ветки после коммитов ветки (base tip), указанной в команде rebase. С помощью rebase можно выполнять целый ряд задач: слияние веток, перемотку (fast forwarding), изменение коммитов текущей ветки (редактирование, именование, удаление, слияние, перетасовка коммитов), пересадку текущей ветки (с помощью опции --onto) и др.